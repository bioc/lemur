
#' @importFrom glmGamPoi vars
#' @export
glmGamPoi::vars

#' Find differential expression neighborhoods
#'
#' @param fit the `lemur_fit` generated by `lemur()`
#' @param group_by If the `independent_matrix` is provided, `group_by` defines
#'   how the pseudobulks are formed.
#' @param contrast a specification which contrast to fit. This defaults to the
#'   `contrast` argument that was used for `test_de` and is stored in `fit$contrast`.
#' @param selection_procedure specify the algorithm that is used to select the
#'   neighborhoods for each gene. Broadly, `selection_procedure = "zscore"` is faster
#'   but less precise than `selection_procedure = "contrast"`.
#' @param directions a string to define the algorithm to select the direction onto
#'   which the cells are projected before searching for the neighborhood.
#'   `directions = "random"` produces denser neighborhoods, whereas `directions = "contrast"`
#'   has usually more power. \cr
#'   Alternatively, this can also be a matrix with one direction for each gene
#'   (i.e., a matrix of size `nrow(fit) * fit$n_embedding`).
#' @param de_mat the matrix with the differential expression values and is only relevant if
#'   `selection_procedure = "zscore"` or `directions = "random"`. Defaults
#'   to an assay called `"DE"` that is produced by `lemur::test_de()`.
#' @param test_data a `SummarizedExperiment` object or a named list of matrices. The
#'   data is used to test if the neighborhood inferred on the training data contain a
#'   reliable significant change. If `test_method` is `"glmGamPoi"` or `"edgeR"` a test
#'   using raw counts is conducted and two matching assays are needed: (1) the continuous
#'   assay (with `continuous_assay_name`) is projected onto the LEMUR fit to find the latent
#'   position of each cell and (2) the count assay (`count_assay_name`) is used for
#'   forming the pseudobulk. If `test_method == "limma"`, only the continuous assay is needed. \cr
#'   The arguments defaults to the test data split of when calling `lemur()`.
#' @param test_data_col_data additional column data for the `test_data` argument.
#' @param test_method choice of test for the pseudobulked differential expression.
#'   [glmGamPoi](https://bioconductor.org/packages/glmGamPoi/) and
#'   [edgeR](https://bioconductor.org/packages/edgeR/) work on an count assay.
#'   [limma](http://bioconductor.org/packages/limma/) works on the continuous assay.
#' @param continuous_assay_name,count_assay_name the assay or list names of `independent_data`.
#' @param design,alignment_design the design to use for the fit. Default: `fit$design`
#' @param include_complement a boolean to specify if the complement of the identified per gene
#'   neighborhood is also returned. It will be marked in the output by `selection = FALSE`.
#' @param verbose Should the method print information during the fitting. Default: `TRUE`.
#' @param ... additional parameters passed to underlying functions.
#'
#' @return a data frame with one entry per gene / neighborhood containing the name
#'   of the neighborhood, the cell indices included in the neighborhood, the number of
#'   cells, and the selection statistic. If `independent_matrix` is not `NULL`, the data frame will
#'   also contain columns from the `limma` / `glmGamPoi` pseudobulk test (pval, adj_pval,
#'   t_statistic / f_statistic, and lfc).
#'
#' @export
find_de_neighborhoods <- function(fit,
                                  group_by,
                                  contrast = fit$contrast,
                                  selection_procedure = c("zscore", "contrast"),
                                  directions = c("random", "contrast", "axis_parallel"),
                                  de_mat = SummarizedExperiment::assays(fit)[["DE"]],
                                  test_data = fit$test_data,
                                  test_data_col_data = NULL,
                                  test_method = c("glmGamPoi", "edgeR", "limma", "none"),
                                  continuous_assay_name = fit$use_assay,
                                  count_assay_name = "counts",
                                  design = fit$design,
                                  alignment_design = fit$alignment_design,
                                  include_complement = TRUE,
                                  verbose = TRUE, ...){
  stopifnot(is(fit, "lemur_fit"))
  test_method <- match.arg(test_method)
  selection_procedure <- match.arg(selection_procedure)
  skip_independent_test <- is.null(test_data) || test_method == "none"
  training_fit <- fit$training_data

  test_data <- handle_test_data_parameter(fit, test_data, test_data_col_data, continuous_assay_name)
  if(nrow(fit) != nrow(test_data)){
    stop("The number of features in 'fit' and 'independent_data' differ.")
  }else{
    if(! is.null(rownames(fit)) && ! is.null(rownames(test_data)) &&
       any(rownames(fit) != rownames(test_data))){
      stop("The rownames differ between 'fit' and 'independent_data'.")
    }
  }

  attr(design, "ignore_degeneracy") <- TRUE
  attr(alignment_design, "ignore_degeneracy") <- TRUE
  projected_indep_data <- project_on_lemur_fit(training_fit, data = test_data, use_assay = continuous_assay_name,
                                               design = design, alignment_design = alignment_design, return = "matrix")


  if(is.character(directions)){
    directions <- match.arg(directions)
    # There is one direction vector for each gene
    if(directions == "random"){
      if(is.null(de_mat)) stop("'directions = \"random\"' needs the predicted difference between two conditions. Please provide a valid 'de_mat'",
                               "argument or call 'fit <- test_de(fit, ...)'")
      stopifnot(all(dim(de_mat) == dim(fit)))
      dirs <- select_directions_from_random_points(n_random_directions = 50, training_fit$embedding, de_mat[,!fit$is_test_data,drop=FALSE])
    }else if(directions == "contrast"){
      dirs <- select_directions_from_contrast(training_fit, {{contrast}})
    }else if(directions == "axis_parallel"){
      if(is.null(de_mat)) stop("'directions = \"axis_parallel\"' needs the predicted difference between two conditions. Please provide a valid 'de_mat'",
                               "argument or call 'fit <- test_de(fit, ...)'")
      stopifnot(all(dim(de_mat) == dim(fit)))
      dirs <- select_directions_from_axes(training_fit$embedding, de_mat[,!fit$is_test_data,drop=FALSE])
    }
  }else{
    stopifnot(is.matrix(directions))
    stopifnot(nrow(directions) == nrow(fit) && ncol(directions) == fit$n_embedding)
    dirs <- directions
  }

  if(verbose) message("Find optimal neighborhood using ", selection_procedure, ".")
  if(selection_procedure == "zscore"){
    if(is.null(de_mat)) stop("'selection_procedure = \"zscore\"' needs the predicted difference between two conditions. Please provide a valid 'de_mat'",
                             "argument or call 'fit <- test_de(fit, ...)'")
    stopifnot(all(dim(de_mat) == dim(fit)))
    de_regions <- find_de_neighborhoods_with_z_score(training_fit, dirs, de_mat[,!fit$is_test_data,drop=FALSE],
                                                     independent_embedding = projected_indep_data,
                                                     include_complement = include_complement, verbose = verbose)
  }else if(selection_procedure == "contrast"){
    de_regions <- find_de_neighborhoods_with_contrast(training_fit, dirs, group_by = {{group_by}}, contrast = {{contrast}},
                                                      independent_embedding = projected_indep_data,
                                                      include_complement = include_complement, ..., verbose = verbose)
  }else if(selection_procedure == "likelihood"){
    # Implement one of Wolfgang's suggestions for the selection procedure
    # de_regions <- find_de_neighborhoods_with_likelihood_ratio(training_fit, dirs, de_mat, include_complement = include_complement)
  }
  if(skip_independent_test){
    colnames <- c("name", "selection", "indices", "n_cells", "sel_statistic")
  }else{
    if(verbose) message("Validate neighborhoods using test data")
    if(! is.null(rownames(fit)) && is.null(rownames(test_data))){
      rownames(test_data) <- rownames(fit)
    }
    if(any(rownames(fit) != rownames(test_data))){
      stop("The rownames of fit and counts don't match.")
    }
    if(rlang::quo_is_null(rlang::enquo(contrast))){
      stop("The contrast argument is 'NULL'. Please specify.")
    }
    tryCatch({
      if(inherits(contrast, "contrast_relation")){
        contrast <- evaluate_contrast_tree(contrast, contrast, \(x, y) x)
      }
    }, error = function(e){
      # Do nothing. The 'contrast' is probably an unquoted expression
    })
    if(test_method != "limma"){
      if(! count_assay_name %in% assayNames(test_data)){
        stop("Trying to execute count-based differential expression analysis on the test data because 'test_method=\"", test_method, "\"'. However, ",
          "'count_assay_name=\"", count_assay_name,  "\"' is not an assay (",  paste0(assayNames(test_data), collapse = ", "),
             ") of the 'independent_data' object.")
      }
      colnames <- c("name", "selection", "indices", "n_cells", "sel_statistic", "pval", "adj_pval", "f_statistic", "df1", "df2", "lfc")
      de_regions <- neighborhood_count_test(de_regions, counts = assay(test_data, count_assay_name), group_by = group_by, contrast = {{contrast}},
                              design = design, col_data = colData(test_data), method = test_method, de_region_index_name = "independent_indices", verbose = verbose)
    }else{
      colnames <- c("name", "selection", "indices", "n_cells", "sel_statistic", "pval", "adj_pval", "t_statistic", "lfc")
      de_regions <- neighborhood_normal_test(de_regions, values = assay(test_data, continuous_assay_name), group_by = group_by, contrast = {{contrast}},
                               design = design, col_data = colData(test_data), shrink = TRUE, de_region_index_name = "independent_indices",  verbose = verbose)
    }
  }

  if(identical(test_data, fit$test_data)){
    # Merge columns
    test_idx <- which(fit$is_test_data)
    train_idx <- which(!fit$is_test_data)
    de_regions$indices <- lapply(seq_len(nrow(de_regions)), \(row){
      c(train_idx[de_regions$indices[[row]]], test_idx[de_regions$independent_indices[[row]]])
    })
    de_regions$independent_indices <- NULL
  }else{
    colnames <- c(colnames[1:3], "independent_indices", colnames[-(1:3)])
  }
  de_regions$n_cells <- lengths(de_regions$indices)
  de_regions[colnames]

}

select_directions_from_axes <- function(embedding, de_mat){
  if(is.null(de_mat)){
    stop("'de_mat' is NULL. Please first call 'lemur::test_de()' to calculate the differential expression matrix.")
  }
  dirs <- diag(nrow = nrow(embedding))
  correlation <- cor(t(embedding), t(de_mat))
  best_proj <- vapply(seq_len(ncol(correlation)), \(idx) which.max(abs(correlation[,idx])), FUN.VALUE = integer(1L))
  dirs[best_proj,,drop=FALSE]
}

select_directions_from_random_points <- function(n_random_directions, embedding, de_mat){
  if(is.null(de_mat)){
    stop("'de_mat' is NULL. Please first call 'lemur::test_de()' to calculate the differential expression matrix.")
  }
  n_cells <- ncol(embedding)
  point_pairs <- matrix(sample.int(n_cells, 2 * n_random_directions, replace = TRUE), nrow = 2)
  # Remove point_paris which are identical
  if(any(point_pairs[1,] == point_pairs[2,])){
    problem <- point_pairs[1,] == point_pairs[2,]
    point_pairs[1,problem] <- (point_pairs[2,problem] %% n_cells) + 1
  }
  dirs <- lapply(seq_len(n_random_directions), \(idx){
    sel <- point_pairs[,idx]
    vec <- embedding[,sel[1]] - embedding[,sel[2]]
    vec / sqrt(sum(vec^2))
  })
  proj <- do.call(rbind, lapply(dirs, \(dir) c(coef(lm.fit(x = matrix(dir, ncol = 1), embedding)))))

  correlation <- cor(t(proj), t(de_mat))
  best_proj <- vapply(seq_len(ncol(correlation)), \(idx) which.max(abs(correlation[,idx])), FUN.VALUE = integer(1L))
  do.call(rbind, dirs[best_proj])
}

select_directions_from_contrast <- function(fit, contrast){
  cntrst <- parse_contrast({{contrast}}, formula = fit$design)
  dirs <- evaluate_contrast_tree(cntrst, cntrst, \(x, .){
    grassmann_map(sum_tangent_vectors(fit$coefficients, x), fit$base_point)
  })
  t(apply(dirs, 1, \(row) row / sqrt(sum(row^2))))
}

select_directions_from_canonical_correlation <- function(embedding, de_mat){
  if(is.null(de_mat)){
    stop("'de_mat' is NULL. Please first call 'lemur::test_de()' to calculate the differential expression matrix.")
  }
  stop("Not yet implemented")
}


find_de_neighborhoods_with_z_score <- function(fit, dirs, de_mat, independent_embedding = NULL,
                                               include_complement = TRUE,
                                               min_neighborhood_size = 10,
                                               verbose = TRUE){
  n_genes <- nrow(fit)
  stopifnot(ncol(fit) == ncol(de_mat))
  stopifnot(nrow(fit) == nrow(de_mat))
  show_progress_bar <- verbose && interactive()
  proj <- dirs %*% fit$embedding
  if(is.null(independent_embedding)){
    independent_embedding <- matrix(nrow = fit$n_embedding, ncol = 0)
  }
  indep_proj <- dirs %*% independent_embedding

  if(show_progress_bar){
    progress_bar <- txtProgressBar(min = 0, max = n_genes, style = 3)
  }
  result <- do.call(rbind, lapply(seq_len(n_genes), \(gene_idx){
    if(show_progress_bar && gene_idx %% 10 == 0){
      setTxtProgressBar(progress_bar, value = gene_idx)
    }
    pr <- proj[gene_idx,]
    ipr <- indep_proj[gene_idx,]
    order_pr <- order(pr)
    max_idx <- cumz_which_abs_max(de_mat[gene_idx,order_pr], min_neighborhood_size = min_neighborhood_size)
    rev_max_idx <- cumz_which_abs_max(rev(de_mat[gene_idx,order_pr]), min_neighborhood_size = min_neighborhood_size)
    if(abs(max_idx$max) > abs(rev_max_idx$max)){
      data.frame(indices = I(list(unname(which(pr <= pr[order_pr][max_idx$idx])))),
                 independent_indices = I(list(unname(which(ipr <= pr[order_pr][max_idx$idx])))),
                 sel_statistic = max_idx$max)
    }else{
      data.frame(indices = I(list(unname(which(pr >= rev(pr[order_pr])[rev_max_idx$idx])))),
                 independent_indices = I(list(unname(which(ipr >= rev(pr[order_pr])[rev_max_idx$idx])))),
                 sel_statistic = rev_max_idx$max)
    }
  }))
  if(show_progress_bar){
    close(progress_bar)
  }
  result$name <- rownames(fit)
  if(is.null(result$name)){
    result$name <- paste0("feature_", seq_len(nrow(fit)))
  }
  result$selection <- TRUE

  if(include_complement){
    all_indices <- seq_len(ncol(fit))
    indep_all_indices <- seq_len(ncol(independent_embedding))
    comp_indices <- lapply(result$indices, \(indices) setdiff(all_indices, indices))
    comp_ind_indices <- lapply(result$independent_indices, \(indices) setdiff(indep_all_indices, indices))
    comp_stat <- vapply(seq_len(nrow(fit)), \(gene_idx){
      sel <- comp_indices[[gene_idx]]
      vals <- de_mat[gene_idx, sel]
      mean(vals) / (sd(vals) / sqrt(length(sel)))
    }, FUN.VALUE = numeric(1L))
    rbind(result, data.frame(name = result$name, indices = I(comp_indices),
                             independent_indices = I(comp_ind_indices), sel_statistic = comp_stat, selection = FALSE))
  }else{
    result
  }
}

find_de_neighborhoods_with_contrast <- function(fit, dirs, group_by, contrast, independent_embedding = NULL,
                                                include_complement = TRUE, ridge_penalty = 0.1, min_neighborhood_size = 10,
                                                verbose = TRUE){
  n_genes <- nrow(fit)
  contrast <- parse_contrast({{contrast}}, formula = fit$design)
  cntrst <- evaluate_contrast_tree(contrast, contrast, \(x, .){
    x
  })
  show_progress_bar <- verbose && interactive()


  # Prepare values
  Y <- assay(fit, fit$use_assay)
  if(rlang::quo_is_null(rlang::enquo(group_by))){
    stop("The 'group_by' argument is NULL. Please provide the names from the column data should be used for aggregating the data.\n",
         "For example, 'group_by = vars(", paste0(head(colnames(fit$colData), n = 2), collapse = ","), ")'")
  }
  group <-  vctrs::vec_group_id(as.data.frame(lapply(group_by, rlang::eval_tidy, data = as.data.frame(fit$colData))))
  design_mat <- fit$design_matrix
  proj <- dirs %*% fit$embedding
  if(is.null(independent_embedding)){
    independent_embedding <- matrix(nrow = fit$n_embedding, ncol = 0)
  }
  indep_proj <- dirs %*% independent_embedding

  if(show_progress_bar){
    progress_bar <- txtProgressBar(min = 0, max = n_genes, style = 3)
  }
  result <- do.call(rbind, lapply(seq_len(n_genes), \(gene_idx){
    if(show_progress_bar && gene_idx %% 10 == 0){
      setTxtProgressBar(progress_bar, value = gene_idx)
    }
    pr <- proj[gene_idx,]
    ipr <- indep_proj[gene_idx,]
    order_pr <- order(pr)
    max_idx <- cum_brls_which_abs_max(Y[gene_idx, order_pr], design_mat[order_pr,], group = group[order_pr],
                                      contrast = cntrst, penalty = ridge_penalty, min_neighborhood_size = min_neighborhood_size)
    rev_max_idx <- cum_brls_which_abs_max(Y[gene_idx, rev(order_pr)], design_mat[rev(order_pr),], group = group[rev(order_pr)],
                                          contrast = cntrst, penalty = ridge_penalty, min_neighborhood_size = min_neighborhood_size)
    if(abs(max_idx$max) > abs(rev_max_idx$max)){
      # Add small number because equality test is unreliable for floats
      thres <- pr[order_pr][max_idx$idx] + 1e-12
      data.frame(indices = I(list(unname(which(pr <= thres)))),
                 independent_indices = I(list(unname(which(ipr <= thres)))),
                 sel_statistic = max_idx$max)
    }else{
      thres <- rev(pr[order_pr])[rev_max_idx$idx] - 1e-12
      data.frame(indices = I(list(unname(which(pr >= thres)))),
                 independent_indices = I(list(unname(which(ipr >= thres)))),
                 sel_statistic = rev_max_idx$max)
    }
  }))
  if(show_progress_bar){
    close(progress_bar)
  }
  result$selection <- TRUE
  result$name <- rownames(fit)
  if(is.null(result$name)){
    result$name <- paste0("feature_", seq_len(nrow(fit)))
  }

  if(include_complement){
    all_indices <- seq_len(ncol(fit))
    indep_all_indices <- seq_len(ncol(independent_embedding))
    comp_indices <- lapply(result$indices, \(indices) setdiff(all_indices, indices))
    comp_ind_indices <- lapply(result$independent_indices, \(indices) setdiff(indep_all_indices, indices))
    comp_stat <-  neighborhood_normal_test(data.frame(name = rownames(Y), indices = I(comp_indices)),
                                           values = Y, group_by = group_by, contrast = cntrst,
                                           design = fit$design, fit$colData, shrink = FALSE, verbose = verbose)$t_statistic
    result <- rbind(result, data.frame(name = result$name, indices = I(comp_indices),
                                       independent_indices = I(comp_ind_indices), sel_statistic = comp_stat, selection = FALSE))
  }
  result
}



neighborhood_count_test <- function(de_regions, counts, group_by, contrast, design, col_data, method = c("glmGamPoi", "edgeR"),
                                    de_region_index_name = "indices", verbose = TRUE){
  method <- match.arg(method)
  mask <- matrix(0, nrow = nrow(de_regions),  ncol = ncol(counts))
  indices <- de_regions[[de_region_index_name]]
  for(idx in seq_len(nrow(de_regions))){
    mask[idx,indices[[idx]]] <- 1
  }

  mask <- if(utils::packageVersion("Matrix") >= "1.4.2"){
    # See email from Martin Maechler from 2022-08-12
    as(as(as(mask, "dMatrix"), "generalMatrix"), "TsparseMatrix")
  }else{
    # This approach is deprecated since 1.4.2 and triggers warnings
    as(mask, "dgTMatrix")
  }

  if(is.null(rownames(counts))){
    rownames(counts) <- paste0("feature_", seq_len(nrow(counts)))
  }
  masked_counts <- as(counts[de_regions$name,,drop=FALSE] * mask, "CsparseMatrix")
  masked_size_factors <- Matrix::sparseMatrix(i = mask@i, j = mask@j, x = mask@x * MatrixGenerics::colSums2(counts)[mask@j + 1L], index1 = FALSE, repr = "C")

  masked_sce <- SingleCellExperiment::SingleCellExperiment(list(masked_counts = masked_counts, masked_size_factors = masked_size_factors),
                                                           colData = col_data)
  if(verbose) message("Form pseudobulk (summing counts)")
  region_psce <- glmGamPoi::pseudobulk(masked_sce, group_by = {{group_by}},
                                       aggregation_functions = list("masked_counts" = "rowSums2",
                                                                    "masked_size_factors" = "rowSums2"),
                                       verbose = verbose)
  if(method == "glmGamPoi"){
    if(verbose) message("Fit glmGamPoi model on pseudobulk data")
    glm_regions <- glmGamPoi::glm_gp(region_psce, design = design, use_assay = "masked_counts", verbose = verbose,
                                     offset = log(assay(region_psce, "masked_size_factors") + 1e-10),
                                     size_factors = FALSE, overdispersion = TRUE)
    de_res <- glmGamPoi::test_de(glm_regions, contrast = {{contrast}})
  }else if(method == "edgeR"){
    if(! requireNamespace("edgeR", quietly = TRUE)){
      stop("to use 'find_de_neighborhoods' in combination with 'edgeR', you need to separately install edgeR.\n",
           "BiocManager::install('edgeR')")
    }
    if(verbose) message("Fit edgeR model on pseudobulk data")

    if(is.matrix(design)){
      design_matrix <- design
    }else{
      design_matrix <- model.matrix(design, data = SummarizedExperiment::colData(region_psce))
    }
    cntrst <- parse_contrast({{contrast}}, design)
    cntrst <- evaluate_contrast_tree(cntrst, cntrst, \(x, .) x)

    edger_y <- edgeR::DGEList(counts = assay(region_psce, "masked_counts"))
    edger_y <- edgeR::scaleOffset(edger_y, offset = log(assay(region_psce, "masked_size_factors") + 1e-10))
    edger_y <- edgeR::estimateDisp(edger_y, design_matrix)
    edger_fit <- edgeR::glmQLFit(edger_y, design_matrix, abundance.trend = TRUE, robust = TRUE)
    edger_fit <- edgeR::glmQLFTest(edger_fit, contrast = cntrst)
    edger_res <- edgeR::topTags(edger_fit, n = nrow(edger_y), sort.by = "none")$table
    de_res <- data.frame(name = rownames(edger_res), pval = edger_res$PValue, adj_pval = edger_res$FDR,
                         f_statistic = edger_res$F, df1 = edger_fit$df.test, df2 = edger_fit$df.total, lfc = edger_res$logFC)
  }
  cbind(de_regions, de_res[,-1])
}


neighborhood_normal_test <- function(de_regions, values, group_by, contrast, design, col_data,
                                     shrink = TRUE, de_region_index_name = "indices", verbose = TRUE){
  if(is.null(de_regions$name)){
    stop("The de_region data frame must contain a column called 'name'.")
  }
  cntrst <- parse_contrast({{contrast}}, formula = design)
  cntrst <- matrix(evaluate_contrast_tree(cntrst, cntrst, \(x, .) x), ncol = 1)
  mask <- matrix(NA, nrow = nrow(de_regions),  ncol = ncol(values))
  indices <- de_regions[[de_region_index_name]]
  for(idx in seq_len(nrow(de_regions))){
    mask[idx,indices[[idx]]] <- 1
  }

  mask <- if(utils::packageVersion("Matrix") >= "1.4.2"){
    # See email from Martin Maechler from 2022-08-12
    as(as(as(mask, "dMatrix"), "generalMatrix"), "TsparseMatrix")
  }else{
    # This approach is deprecated since 1.4.2 and triggers warnings
    as(mask, "dgTMatrix")
  }
  if(is.null(rownames(values))){
    if(nrow(values) == nrow(de_regions)){
      rownames(values) <- de_regions$name
    }else{
      stop("'values' does not have rownames and its number of rows does not match the number of rows ",
           "in 'de_regions'. Thus the matching between 'de_regions' and 'values' is ambiguous.")
    }
  }
  masked_values <- as(values[de_regions$name,,drop=FALSE] * mask, "CsparseMatrix")
  if(verbose) message("Form pseudobulk (averaging values)")
  groups <- lapply(group_by, rlang::eval_tidy, data = as.data.frame(col_data))
  if(is.null(groups)){
    stop("'group_by' must not be 'NULL'.")
  }
  names(groups) <- vapply(group_by, rlang::as_label, character(1L))
  split_res <- vctrs::vec_group_loc(as.data.frame(groups))
  group_split <- split_res$loc
  names(group_split) <- do.call(paste, c(split_res$key, sep = "."))

  M <- aggregate_matrix(masked_values, group_split, MatrixGenerics::rowMeans2, na.rm = TRUE)
  model_matrix <- model.matrix(design, data = split_res$key)

  if(! is_contrast_estimable(cntrst, model_matrix)){
    stop("The contrast is not estimable from the model_matrix")
  }

  if(verbose) message("Fit limma model")
  suppressWarnings({
    # limma warns about missing values. Here we expect missing values though.
    lm_fit <- limma::lmFit(M, model_matrix)
  })
  lm_fit <- limma::contrasts.fit(lm_fit, contrasts = cntrst)
  if(shrink){
    lm_fit <- tryCatch({
      limma::eBayes(lm_fit, trend = TRUE, robust = TRUE)
    }, error = function(err){
      limma::eBayes(lm_fit, trend = FALSE, robust = TRUE)
    })
  }else{
    lm_fit <- limma_eBayes_without_shrinkage(lm_fit)
  }
  tt <- limma::topTable(lm_fit, number = nrow(lm_fit$coefficients),
                        adjust.method = "BH", sort.by = "none")
  for(row in which(MatrixGenerics::rowAnyNAs(M))){
    # limma can return misleading results if there missing values in the wrong
    # places (see https://support.bioconductor.org/p/9150300/)
    if(! is_contrast_estimable(cntrst, model_matrix[!is.na(M[row,]),,drop=FALSE])){
      tt[row, c("P.Value", "adj.P.Val", "t", "logFC")] <- NA_real_
    }
  }
  cbind(de_regions, pval = tt$P.Value, adj_pval = tt$adj.P.Val, t_statistic = tt$t, lfc = tt$logFC)
}



#' @importFrom glmGamPoi vars
#' @export
glmGamPoi::vars

#' Find differential expression neighborhoods
#'
#' @param fit the `lemur_fit` generated by `lemur()`
#' @param independent_matrix a matrix with the same dimensions as fit that contains
#'   independent values and is used to confirm the significance of the neighborhoods.
#'   The argument is optional, if it is provided the function returns additional
#'   columns with the significance of each neighborhood based on a pseudobulked
#'   differential expression test using [`glmGamPoi`](10.18129/B9.bioc.glmGamPoi) or
#'   [`limma`](10.18129/B9.bioc.limma) (depending on `independent_matrix_type`).
#' @param group_by If the `independent_matrix` is provided, `group_by` defines
#'   how the pseudobulks are formed.
#' @param selection_procedure specify the algorithm that is used to select the
#'   neighborhoods for each gene. Broadly, `selection_procedure = "zscore"` is faster
#'   but less precise than `selection_procedure = "contrast"`.
#' @param directions a string to define the algorithm to select the direction onto
#'   which the cells are projected before searching for the neighborhood.
#'   `directions = "random"` produces denser neighborhoods, whereas `directions = "contrast"`
#'   has usually more power. \cr
#'   Alternatively, this can also be a matrix with one direction for each gene
#'   (i.e., a matrix of size `nrow(fit) * fit$n_embedding`).
#' @param independent_matrix_type is the `independent_matrix` argument a matrix of counts or
#'   continuous values?
#' @param de_mat the matrix with the differential expression values and is only relevant if
#'   `selection_procedure = "zscore"` or `directions = "random"`. Defaults
#'   to an assay called `"DE"` that is produced by `lemur::test_de()`.
#' @param contrast a specification which contrast to fit. This defaults to the
#'   `contrast` argument that was used for `test_de` and is stored in `fit$contrast`.
#' @param n_random_directions the number of random projections to use if `directions = "random"`.
#'   Default: `50`.
#' @param count_test_method if you provide a count matrix to the `independent_matrix` argument,
#'   you can either test for differential expression on the pseudobulk using
#'   [glmGamPoi](https://bioconductor.org/packages/glmGamPoi/) or
#'   [edgeR](https://bioconductor.org/packages/edgeR/).
#' @param design the design to use for the fit. Default: `fit$design`
#' @param include_complement a boolean to specify if the complement of the identified per gene
#'   neighborhood is also returned. It will be marked in the output by `selection = FALSE`.
#' @param verbose Should the method print information during the fitting. Default: `TRUE`.
#' @param ... additional parameters passed to underlying functions.
#'
#' @return a data frame with one entry per gene / neighborhood containing the name
#'   of the neighborhood, the cell indices included in the neighborhood, the number of
#'   cells, and the selection statistic. If `independent_matrix` is not `NULL`, the data frame will
#'   also contain columns from the `limma` / `glmGamPoi` pseudobulk test (pval, adj_pval,
#'   t_statistic / f_statistic, and lfc).
#'
#' @export
find_de_neighborhoods <- function(fit,
                                  independent_matrix = NULL,
                                  group_by = NULL,
                                  selection_procedure = c("zscore", "contrast"),
                                  directions = c("random", "contrast", "axis_parallel"),
                                  independent_matrix_type = c("counts", "continuous"),
                                  de_mat = assay(fit, "DE"),
                                  contrast = fit$contrast,
                                  n_random_directions = 50,
                                  count_test_method = c("glmGamPoi", "edgeR"),
                                  design = fit$design,
                                  include_complement = TRUE,
                                  verbose = TRUE, ...){
  stopifnot(is(fit, "lemur_fit"))
  independent_matrix_type <- match.arg(independent_matrix_type)

  if(is.character(directions)){
    directions <- match.arg(directions)
    if(directions == "random"){
      dirs <- select_directions_from_random_points(n_random_directions, fit$embedding, de_mat)
    }else if(directions == "contrast"){
      dirs <- select_directions_from_contrast(fit, {{contrast}})
    }else if(directions == "axis_parallel"){
      dirs <- select_directions_from_axes(fit$embedding, de_mat)
    }
  }else{
    stopifnot(is.matrix(directions))
    stopifnot(nrow(directions) == nrow(fit) && ncol(directions) == fit$n_embedding)
    dirs <- directions
  }

  selection_procedure <- match.arg(selection_procedure)
  if(verbose) message("Find optimal neighborhood using ", selection_procedure, ".")
  if(selection_procedure == "zscore"){
    de_regions <- find_de_neighborhoods_with_z_score(fit, dirs, de_mat, include_complement = include_complement, verbose = verbose)
  }else if(selection_procedure == "contrast"){
    de_regions <- find_de_neighborhoods_with_contrast(fit, dirs, group_by = {{group_by}}, contrast = contrast, include_complement = include_complement, ..., verbose = verbose)
  }else if(selection_procedure == "likelihood"){
    # Implement one of Wolfgang's suggestions for the selection procedure
    # de_regions <- find_de_neighborhoods_with_likelihood_ratio(fit, dirs, de_mat, include_complement = include_complement)
  }
  de_regions$n_cells <- lengths(de_regions$indices)
  de_regions <- de_regions[, c("name", "selection", "indices", "n_cells", "sel_statistic")]


  if(is.null(independent_matrix)){
    de_regions
  }else{
    if(verbose) message("Validate neighborhoods using independent ", independent_matrix_type, " data.")
    stopifnot(all(dim(fit) == dim(independent_matrix)))
    if(! is.null(rownames(fit)) && is.null(rownames(independent_matrix))){
      rownames(independent_matrix) <- rownames(fit)
    }
    if(any(rownames(fit) != rownames(independent_matrix))){
      stop("The rownames of fit and counts don't match.")
    }
    if(rlang::quo_is_null(rlang::enquo(contrast))){
      stop("The contrast argument is 'NULL'. Please specify.")
    }
    tryCatch({
      if(inherits(contrast, "contrast_relation")){
        contrast <- evaluate_contrast_tree(contrast, contrast, \(x, y) x)
      }
    }, error = function(e){
      # Do nothing. The 'contrast' is probably an unquoted expression
    })
    result <- if(independent_matrix_type == "counts"){
      neighborhood_count_test(de_regions, counts = independent_matrix, group_by = group_by, contrast = {{contrast}},
                              design = design, col_data = fit$colData, method = count_test_method, verbose = verbose)
    }else{
      neighborhood_normal_test(de_regions, values = independent_matrix, group_by = group_by, contrast = {{contrast}},
                               design = design, col_data = fit$colData, shrink = TRUE,  verbose = verbose)
    }
    result
  }
}

select_directions_from_axes <- function(embedding, de_mat){
  if(is.null(de_mat)){
    stop("'de_mat' is NULL. Please first call 'lemur::test_de()' to calculate the differential expression matrix.")
  }
  dirs <- diag(nrow = nrow(embedding))
  correlation <- cor(t(embedding), t(de_mat))
  best_proj <- vapply(seq_len(ncol(correlation)), \(idx) which.max(abs(correlation[,idx])), FUN.VALUE = integer(1L))
  dirs[best_proj,,drop=FALSE]
}

select_directions_from_random_points <- function(n_random_directions, embedding, de_mat){
  if(is.null(de_mat)){
    stop("'de_mat' is NULL. Please first call 'lemur::test_de()' to calculate the differential expression matrix.")
  }
  n_cells <- ncol(embedding)
  point_pairs <- matrix(sample.int(n_cells, 2 * n_random_directions, replace = TRUE), nrow = 2)
  # Remove point_paris which are identical
  if(any(point_pairs[1,] == point_pairs[2,])){
    problem <- point_pairs[1,] == point_pairs[2,]
    point_pairs[1,problem] <- (point_pairs[2,problem] %% n_cells) + 1
  }
  dirs <- lapply(seq_len(n_random_directions), \(idx){
    sel <- point_pairs[,idx]
    vec <- embedding[,sel[1]] - embedding[,sel[2]]
    vec / sqrt(sum(vec^2))
  })
  proj <- do.call(rbind, lapply(dirs, \(dir) c(coef(lm.fit(x = matrix(dir, ncol = 1), embedding)))))

  correlation <- cor(t(proj), t(de_mat))
  best_proj <- vapply(seq_len(ncol(correlation)), \(idx) which.max(abs(correlation[,idx])), FUN.VALUE = integer(1L))
  do.call(rbind, dirs[best_proj])
}

select_directions_from_contrast <- function(fit, contrast){
  cntrst <- parse_contrast({{contrast}}, formula = fit$design)
  dirs <- evaluate_contrast_tree(cntrst, cntrst, \(x, .){
    grassmann_map(sum_tangent_vectors(fit$coefficients, x), fit$base_point)
  })
  t(apply(dirs, 1, \(row) row / sqrt(sum(row^2))))
}

select_directions_from_canonical_correlation <- function(embedding, de_mat){
  if(is.null(de_mat)){
    stop("'de_mat' is NULL. Please first call 'lemur::test_de()' to calculate the differential expression matrix.")
  }
  stop("Not yet implemented")
}


find_de_neighborhoods_with_z_score <- function(fit, dirs, de_mat, include_complement, verbose = TRUE){
  n_genes <- nrow(fit)
  stopifnot(ncol(fit) == ncol(de_mat))
  stopifnot(nrow(fit) == nrow(de_mat))
  proj <- dirs %*% fit$embedding

  result <- do.call(rbind, lapply(seq_len(n_genes), \(gene_idx){
    pr <- proj[gene_idx,]
    order_pr <- order(pr)
    max_idx <- cumz_which_abs_max(de_mat[gene_idx,order_pr])
    rev_max_idx <- cumz_which_abs_max(rev(de_mat[gene_idx,order_pr]))
    if(abs(max_idx$max) > abs(rev_max_idx$max)){
      data.frame(indices = I(list(unname(which(pr <= pr[order_pr][max_idx$idx])))), sel_statistic = max_idx$max)
    }else{
      data.frame(indices = I(list(unname(which(pr >= rev(pr[order_pr])[rev_max_idx$idx])))), sel_statistic = rev_max_idx$max)
    }
  }))
  result$name <- rownames(fit)
  if(is.null(result$name)){
    result$name <- paste0("feature_", seq_len(nrow(fit)))
  }
  result$selection <- TRUE

  if(include_complement){
    all_indices <- seq_len(ncol(fit))
    comp_indices <- lapply(result$indices, \(indices) setdiff(all_indices, indices))
    comp_stat <- vapply(seq_len(nrow(fit)), \(gene_idx){
      sel <- comp_indices[[gene_idx]]
      vals <- de_mat[gene_idx, sel]
      mean(vals) / (sd(vals) / sqrt(length(sel)))
    }, FUN.VALUE = numeric(1L))
    rbind(result, data.frame(name = result$name, indices = I(comp_indices), sel_statistic = comp_stat, selection = FALSE))
  }else{
    result
  }
}

find_de_neighborhoods_with_contrast <- function(fit, dirs, group_by, contrast, include_complement,
                                                ridge_penalty = 1e-6, verbose = TRUE){
  n_genes <- nrow(fit)
  contrast <- parse_contrast({{contrast}}, formula = fit$design)
  cntrst <- evaluate_contrast_tree(contrast, contrast, \(x, .){
    x
  })

  # Prepare values
  Y <- assay(fit, "expr")
  if(rlang::quo_is_null(rlang::enquo(group_by))){
    stop("The 'group_by' argument is NULL. Please provide the names from the column data should be used for aggregating the data.\n",
         "For example, 'group_by = vars(", paste0(head(colnames(fit$colData), n = 2), collapse = ","), ")'")
  }
  group <-  vctrs::vec_group_id(as.data.frame(lapply(group_by, rlang::eval_tidy, data = as.data.frame(fit$colData))))
  design_mat <- fit$design_matrix
  proj <- dirs %*% fit$embedding

  result <- do.call(rbind, lapply(seq_len(n_genes), \(gene_idx){
    pr <- proj[gene_idx,]
    order_pr <- order(pr)
    max_idx <- cum_brls_which_abs_max(Y[gene_idx, order_pr], design_mat[order_pr,], group = group[order_pr],
                                      contrast = cntrst, penalty = ridge_penalty)
    rev_max_idx <- cum_brls_which_abs_max(Y[gene_idx, rev(order_pr)], design_mat[rev(order_pr),], group = group[rev(order_pr)],
                                          contrast = cntrst, penalty = ridge_penalty)
    if(abs(max_idx$max) > abs(rev_max_idx$max)){
      data.frame(indices = I(list(unname(which(pr <= pr[order_pr][max_idx$idx])))), sel_statistic = max_idx$max)
    }else{
      data.frame(indices = I(list(unname(which(pr >= rev(pr[order_pr])[rev_max_idx$idx])))), sel_statistic = rev_max_idx$max)
    }
  }))
  result$selection <- TRUE
  result$name <- rownames(fit)
  if(is.null(result$name)){
    result$name <- paste0("feature_", seq_len(nrow(fit)))
  }

  if(include_complement){
    all_indices <- seq_len(ncol(fit))
    comp_indices <- lapply(result$indices, \(indices) setdiff(all_indices, indices))
    comp_stat <-  neighborhood_normal_test(data.frame(name = rownames(Y), indices = I(comp_indices)),
                                           values = Y, group_by = group_by, contrast = cntrst,
                                           design = fit$design, fit$colData, shrink = FALSE, verbose = verbose)$t_statistic
    result <- rbind(result, data.frame(name = result$name, indices = I(comp_indices), sel_statistic = comp_stat, selection = FALSE))
  }
  result
}



neighborhood_count_test <- function(de_regions, counts, group_by, contrast, design, col_data, method = c("glmGamPoi", "edgeR"), verbose = TRUE){
  method <- match.arg(method)
  mask <- matrix(0, nrow = nrow(de_regions),  ncol = ncol(counts))
  for(idx in seq_len(nrow(de_regions))){
    mask[idx,de_regions$indices[[idx]]] <- 1
  }

  mask <- if(utils::packageVersion("Matrix") >= "1.4.2"){
    # See email from Martin Maechler from 2022-08-12
    as(as(as(mask, "dMatrix"), "generalMatrix"), "TsparseMatrix")
  }else{
    # This approach is deprecated since 1.4.2 and triggers warnings
    as(mask, "dgTMatrix")
  }

  if(is.null(rownames(counts))){
    rownames(counts) <- paste0("feature_", seq_len(nrow(counts)))
  }
  masked_counts <- as(counts[de_regions$name,,drop=FALSE] * mask, "CsparseMatrix")
  masked_size_factors <- Matrix::sparseMatrix(i = mask@i, j = mask@j, x = mask@x * MatrixGenerics::colSums2(counts)[mask@j + 1L], index1 = FALSE, repr = "C")

  masked_sce <- SingleCellExperiment::SingleCellExperiment(list(masked_counts = masked_counts, masked_size_factors = masked_size_factors),
                                                           colData = col_data)
  if(verbose) message("Form pseudobulk (summing counts)")
  region_psce <- glmGamPoi::pseudobulk(masked_sce, group_by = {{group_by}},
                                       aggregation_functions = list("masked_counts" = "rowSums2",
                                                                    "masked_size_factors" = "rowSums2"),
                                       verbose = verbose)
  if(method == "glmGamPoi"){
    if(verbose) message("Fit glmGamPoi model on pseudobulk data")
    glm_regions <- glmGamPoi::glm_gp(region_psce, design = design, use_assay = "masked_counts", verbose = verbose,
                                     offset = log(assay(region_psce, "masked_size_factors") + 1e-10),
                                     size_factors = FALSE, overdispersion = TRUE)
    de_res <- glmGamPoi::test_de(glm_regions, contrast = {{contrast}})
  }else if(method == "edgeR"){
    if(! requireNamespace("edgeR", quietly = TRUE)){
      stop("to use 'find_de_neighborhoods' in combination with 'edgeR', you need to separately install edgeR.\n",
           "BiocManager::install('edgeR')")
    }
    if(verbose) message("Fit edgeR model on pseudobulk data")

    if(is.matrix(design)){
      design_matrix <- design
    }else{
      design_matrix <- model.matrix(design, data = SummarizedExperiment::colData(region_psce))
    }
    cntrst <- parse_contrast({{contrast}}, design)
    cntrst <- evaluate_contrast_tree(cntrst, cntrst, \(x, .) x)

    edger_y <- edgeR::DGEList(counts = assay(region_psce, "masked_counts"))
    edger_y <- edgeR::scaleOffset(edger_y, offset = log(assay(region_psce, "masked_size_factors") + 1e-10))
    edger_y <- edgeR::estimateDisp(edger_y, design_matrix)
    edger_fit <- edgeR::glmQLFit(edger_y, design_matrix, abundance.trend = TRUE, robust = TRUE)
    edger_fit <- edgeR::glmQLFTest(edger_fit, contrast = cntrst)
    edger_res <- edgeR::topTags(edger_fit, n = nrow(edger_y), sort.by = "none")$table
    de_res <- data.frame(name = rownames(edger_res), pval = edger_res$PValue, adj_pval = edger_res$FDR,
                         f_statistic = edger_res$F, df1 = edger_fit$df.test, df2 = edger_fit$df.total, lfc = edger_res$logFC)
  }
  cbind(de_regions, de_res[,-1])
}


neighborhood_normal_test <- function(de_regions, values, group_by, contrast, design, col_data,
                                     shrink = TRUE, verbose = TRUE){
  if(is.null(de_regions$name)){
    stop("The de_region data frame must contain a column called 'name'.")
  }
  cntrst <- parse_contrast({{contrast}}, formula = design)
  cntrst <- matrix(evaluate_contrast_tree(cntrst, cntrst, \(x, .) x), ncol = 1)
  mask <- matrix(NA, nrow = nrow(de_regions),  ncol = ncol(values))
  for(idx in seq_len(nrow(de_regions))){
    mask[idx,de_regions$indices[[idx]]] <- 1
  }

  mask <- if(utils::packageVersion("Matrix") >= "1.4.2"){
    # See email from Martin Maechler from 2022-08-12
    as(as(as(mask, "dMatrix"), "generalMatrix"), "TsparseMatrix")
  }else{
    # This approach is deprecated since 1.4.2 and triggers warnings
    as(mask, "dgTMatrix")
  }
  if(is.null(rownames(values))){
    if(nrow(values) == nrow(de_regions)){
      rownames(values) <- de_regions$name
    }else{
      stop("'values' does not have rownames and its number of rows does not match the number of rows ",
           "in 'de_regions'. Thus the matching between 'de_regions' and 'values' is ambiguous.")
    }
  }
  masked_values <- as(values[de_regions$name,,drop=FALSE] * mask, "CsparseMatrix")
  if(verbose) message("Form pseudobulk (averaging values)")
  groups <- lapply(group_by, rlang::eval_tidy, data = as.data.frame(col_data))
  names(groups) <- vapply(group_by, rlang::as_label, character(1L))
  split_res <- vctrs::vec_group_loc(as.data.frame(groups))
  group_split <- split_res$loc
  names(group_split) <- do.call(paste, c(split_res$key, sep = "."))

  M <- aggregate_matrix(masked_values, group_split, MatrixGenerics::rowMeans2, na.rm = TRUE)
  model_matrix <- model.matrix(design, data = split_res$key)

  if(! is_contrast_estimable(cntrst, model_matrix)){
    stop("The contrast is not estimable from the model_matrix")
  }

  if(verbose) message("Fit limma model")
  suppressWarnings({
    # limma warns about missing values. Here we expect missing values though.
    lm_fit <- limma::lmFit(M, model_matrix)
  })
  lm_fit <- limma::contrasts.fit(lm_fit, contrasts = cntrst)
  if(shrink){
    lm_fit <- limma::eBayes(lm_fit, trend = TRUE, robust = TRUE)
  }else{
    lm_fit <- limma_eBayes_without_shrinkage(lm_fit)
  }
  tt <- limma::topTable(lm_fit, number = nrow(lm_fit$coefficients),
                        adjust.method = "BH", sort.by = "none")
  for(row in which(MatrixGenerics::rowAnyNAs(M))){
    # limma can return misleading results if there missing values in the wrong
    # places (see https://support.bioconductor.org/p/9150300/)
    if(! is_contrast_estimable(cntrst, model_matrix[!is.na(M[row,]),,drop=FALSE])){
      tt[row, c("P.Value", "adj.P.Val", "t", "logFC")] <- NA_real_
    }
  }
  cbind(de_regions, pval = tt$P.Value, adj_pval = tt$adj.P.Val, t_statistic = tt$t, lfc = tt$logFC)
}


---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%",
  dpi = 300
)
```

# Latent Embedding Multivariate Regression (LEMUR)

<!-- badges: start -->

<!-- badges: end -->

The goal of `lemur` is to enable easy analysis of multi-condition single-cell data. `lemur` fits a latent embedding regression model, which means it tries to find a PCA-like embedding for each condition and parameterizes the transition from one embedding to another. For this task, `lemur` uses geodesic regression on a Grassmann manifold, which is solved efficiently using tangent-space linear modeling. `lemur` works with arbitrary experimental designs that can be expressed using a design matrix. The result is an interpretable model of the gene expression patterns.

![Schematic of the matrix decomposition at the core of LEMUR](man/figures/equation_schematic.png)

## Installation

You can install the development version of lemur from Github:

``` r
devtools::install_github("const-ae/lemur")
```

`lemur` depends on recent features from [`glmGamPoi`](https://github.com/const-ae/glmGamPoi), so make sure that `packageVersion("glmGamPoi")` is larger than `1.12.0`.

## A word of caution

This package is being actively developed, and I am still making breaking changes. I would be delighted if you decide to try out the package. Please do open an issue if you think you found a bug, have an idea for a cool feature, or have any questions about how LEMUR works. Consider this an *alpha* release with the goal to gather feedback, but be aware that code written against the current version of lemur might not work in the future.

## Quick start

```{r preparation, echo=FALSE}
set.seed(1)
sce <- lemur::glioblastoma_example_data[1:50,sample.int(5000, size = 500)]
```

```{r quick_start, message=FALSE, warning=FALSE}
library("lemur")
library("SingleCellExperiment")

fit <- lemur(sce, design = ~ patient_id + condition, n_embedding = 15)
fit <- align_harmony(fit)   # This step is optional
fit <- test_de(fit, contrast = cond(condition = "ctrl") - cond(condition = "panobinostat"))
nei <- find_de_neighborhoods(fit, group_by = vars(patient_id, condition))
```

## A worked through example

We will demonstrate `lemur` using a dataset by Zhao et al. (2021). The data consist of tumor biopsies from five glioblastomas which were treated with the drug panobinostat and with a control. Accordingly, we will analyze ten samples (patient-treatment combinations) using a paired experimental design.

We start by loading some required packages.

```{r load_packages, message=FALSE, warning=FALSE}
library("tidyverse")
library("SingleCellExperiment")
library("lemur")
set.seed(42)
```

We use a reduced-size version of the glioblastoma data that ships with the `lemur` package.

```{r load_data}
lemur::glioblastoma_example_data
```

Initially, the data separates by the known covariates `patient_id` and `condition`.

```{r raw_umap}
orig_umap <- uwot::umap(as.matrix(t(logcounts(glioblastoma_example_data))))

as_tibble(colData(glioblastoma_example_data)) %>%
  mutate(umap = orig_umap) %>%
  ggplot(aes(x = umap[,1], y = umap[,2])) +
    geom_point(aes(color = patient_id, shape = condition), size = 0.5) +
    labs(title = "UMAP of logcounts")
```

We fit the LEMUR model by calling `lemur()`. We provide the experimental design using a formula. The elements of the formula can refer to columns of the `colData` of the `SingleCellExperiment` object. We also set the number of latent dimensions, which has a similar interpretation as the number of dimensions in PCA. Optionally, we can further align corresponding cells using manually annotated cell types (`align_by_grouping`) or an automated alignment procedure (e.g., `align_harmony`).

The `test_fraction` argument sets the fraction of cells which are exclusively used to test for differential expression and not for inferring the LEMUR parameters. It balances the sensitivity to detect subtle patterns in the latent space against the power to detect differentially expressed genes.

```{r fit_lemur}
fit <- lemur(glioblastoma_example_data, design = ~ patient_id + condition, 
             n_embedding = 15, test_fraction = 0.5)

# Optionally, align cell positions across conditions
# Either with manual annotation by calling `align_by_grouping` or
# with automatically inferred correspondences by calling `align_harmony`
fit <- align_harmony(fit)

fit
```

The `lemur()` function returns an object that extends `SingleCellExperiment` and thus supports subsetting and all the usual data accessor methods (e.g., `nrow`, `assay`, `colData`, `rowData`). In addition, `lemur` overloads the `$` operator to allow easy access to additional fields produced by the LEMUR model. For example, the low-dimensional embedding can be accessed using `fit$embedding`:

```{r lemur_umap}
umap <- uwot::umap(t(fit$embedding))

as_tibble(fit$colData) %>%
  mutate(umap = umap) %>%
  ggplot(aes(x = umap[,1], y = umap[,2])) +
    geom_point(aes(color = patient_id, shape = condition), size = 0.5) +
    labs(title = "UMAP of latent space from LEMUR")
```

Next, we will calculate the expected effect of the panobinostat treatment for each gene and cell. The `test_de` function takes a `lemur_fit_obj` and returns with a new assay `"DE"` with the predicted difference between two conditions specified in the `contrast`. Note that `lemur` implements a special notation for contrasts. Instead of providing a contrast vector or design matrix column names, you provide for each *condition* the levels, and `lemur` automatically forms the contrast vector. This makes the contrast more readable.

```{r lemur_test_de}
fit <- test_de(fit, contrast = cond(condition = "panobinostat") - cond(condition = "ctrl"))
```

We can pick any gene and show the differential expression pattern on the UMAP plot:

```{r umap_de}
# EEF1A1
sel_gene <- "ENSG00000156508"

tibble(umap = umap) %>%
  mutate(expr = assay(fit, "DE")[sel_gene,]) %>%
  ggplot(aes(x = umap[,1], y = umap[,2])) +
    geom_point(aes(color = expr)) +
    scale_color_gradient2() +
    labs(title = "Differential expression on UMAP plot")
```

Alternatively, we can use the matrix of differential expression values (`assay(fit, "DE")`) to guide the selection of cell neighborhoods that show consistent differential expression. If we provide a count matrix, the function uses a pseudobulked differential expression test to confirm the gene expression differences on the count level.

The `group_by` argument determines how the pseudobulk samples are formed. It specifies the columns in the `fit$colData` that are used to define a sample and is inspired by the `group_by` function in `dplyr`. Typically, you provide the covariates that were used for the experimental design plus the sample id (in this case `patient_id`).

```{r de_neighborhoods}
neighborhoods <- find_de_neighborhoods(fit, group_by = vars(patient_id, condition),
                                      include_complement = FALSE)

as_tibble(neighborhoods) %>%
  arrange(pval) %>%
  left_join(as_tibble(rowData(fit)), by = c("name" = "gene_id")) %>%
  dplyr::select(name, symbol, n_cells, pval, adj_pval)
```

We can now specifically select regions with significant differential expression:

```{r umap_de2}
# HLA-DRB1
sel_gene <- "ENSG00000196126"

tibble(umap = umap) %>%
  mutate(expr = assay(fit, "DE")[sel_gene,]) %>%
  ggplot(aes(x = umap[,1], y = umap[,2])) +
    geom_point(aes(color = expr)) +
    scale_color_gradient2() +
    labs(title = "Differential expression on UMAP plot")
```

To plot the boundaries of the differential expression neighborhood, we create a helper dataframe and use the `geom_density2d` function from `ggplot2`. To avoid the cutting of the boundary to the extremes of the cell coordinates, add `lims` to the plot with an appropriately large limit.

```{r umap_de3}
neighborhood_coordinates <- neighborhoods %>%
  dplyr::filter(selection & name == sel_gene) %>%
  mutate(cell_id = map(indices, \(idx) colnames(fit)[idx])) %>%
  unnest(c(indices, cell_id)) %>%
  left_join(tibble(cell_id = rownames(umap), umap), by = "cell_id") %>%
  dplyr::select(name, cell_id, umap)

tibble(umap = umap) %>%
  mutate(expr = assay(fit, "DE")[sel_gene,]) %>%
  ggplot(aes(x = umap[,1], y = umap[,2])) +
    geom_point(aes(color = expr)) +
    scale_color_gradient2() +
    geom_density2d(data = neighborhood_coordinates, breaks = 0.1, 
                   contour_var = "ndensity", color = "black") +
    labs(title = "Differential expression with neighborhood boundary")

```

We make a volcano plot of the differential expression results to better understand the expression differences across all genes.

```{r volcano_plot}
neighborhoods %>%
  ggplot(aes(x = lfc, y = -log10(pval))) +
    geom_point(aes(color  = adj_pval < 0.1)) +
    labs(title = "Volcano plot of the neighborhoods")

neighborhoods %>%
  ggplot(aes(x = n_cells, y = -log10(pval))) +
    geom_point(aes(color  = adj_pval < 0.1)) +
    labs(title = "Neighborhood size vs neighborhood significance")
```

# FAQ

##### I have already integrated my data using Harmony / MNN / Seurat. Can I call `lemur` directly with the aligned data?

No. You need to call `lemur` with the unaligned data so that it can learn how much the expression of each gene changes between conditions.

##### Can I call lemur with [sctransformed](https://github.com/satijalab/sctransform) instead of log-transformed data?

Yes. You can call lemur with any variance stabilized count matrix. Based on a [previous project](https://www.biorxiv.org/content/10.1101/2021.06.24.449781v4), I recommend to use log-transformation, but other methods will work just fine.

##### My data appears less integrated after calling `lemur()` than before. What is happening?!

This is a known issue and can be caused if the data has large compositional shifts (for example, if one cell type disappears). The problem is that the initial linear regression step, which centers the conditions relative to each other, overcorrects and introduces a consistent shift in the latent space. You can either use `align_by_grouping` / `align_harmony` to correct for this effect or manually fix the regression coefficient to zero:

```{r fix_linear_coef, message=FALSE, warning=FALSE}
fit <- lemur(sce, design = ~ patient_id + condition, n_embedding = 15, linear_coefficient_estimator = "zero")
```

##### The conditions still separate if I plot the data using UMAP / tSNE. Even after calling `align_harmony` / `align_neighbors`. What should I do?

You can try to increase `n_embedding`. If this still does not help, there is little use in inferring differential expression neighborhoods. But as I haven't encountered such a dataset yet, I would like to try it out myself. If you can share the data publicly, please open an issue.

##### How do I make `lemur` faster?

Several parameters influence the duration to fit the LEMUR model and find differentially expressed neighborhoods:

-   Make sure that your data is stored in memory (not a `DelayedArray`) either as a sparse dgCMatrix or dense matrix.
-   A larger `test_fraction` means fewer cells are used to fit the model (and more cells are used for the DE test), which speeds up many steps.
-   A smaller `n_embedding` reduces the latent dimensions of the fit, which makes the model less flexible, but speeds up the `lemur()` call.
-   Providing a pre-calculated set of matching cells and calling `align_grouping` is faster than `align_harmony`.
-   Setting `selection_procedure = "contrast"` in `find_de_neighborhoods` often produces better neighborhoods, but is a lot slower than `selection_procedure = "zscore"`.
-   Setting `size_factor_method = "ratio"` in `find_de_neighborhoods` makes the DE more powerful, but is a lot slower than `size_factor_method = "normed_sum"`.

# Session Info

```{r session_info}
sessionInfo()
```
